// SPDX-License-Identifier: GPL-3.0

// Logic mostly ported from OpenZeppelin contracts for use in the
// context of a Safe Multisig. Highlights:
// - Removed all functions except `functionCall` and `functionCallWithValue`
// - Functions modified to accept a `ISafe` as the first argument which
//   is the Safe used to execute the transaction.
// - Modified `functionCallWithValue` to execute the transaction via a Safe,
//   designed to be called from a module.
// - Added imports for Safe related contracts.
// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.0.1/contracts/utils/Address.sol>

// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)

pragma solidity >=0.8.0 <0.9.0;

import {Safe, Enum} from "lib/composable-cow/lib/safe/contracts/Safe.sol";

/**
 * @dev Collection of functions related to the address type
 */
library SafeModuleAddress {
    /**
     * @dev The ETH balance of the account is not enough to perform the operation.
     */
    error AddressInsufficientBalance(address account);

    /**
     * @dev There's no code at `target` (it is not a contract).
     */
    error AddressEmptyCode(address target);

    /**
     * @dev A call to an address target failed. The target may have reverted.
     */
    error FailedInnerCall();

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason or custom error, it is bubbled
     * up by this function (like regular Solidity function calls). However, if
     * the call reverted with no returned reason, this function reverts with a
     * {FailedInnerCall} error.
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     */
    function functionCall(Safe safe, address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(safe, target, data, 0);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     */
    function functionCallWithValue(Safe safe, address target, bytes memory data, uint256 value)
        internal
        returns (bytes memory)
    {
        if (address(safe).balance < value) {
            revert AddressInsufficientBalance(address(safe));
        }
        (bool success, bytes memory returndata) =
            safe.execTransactionFromModuleReturnData(target, value, data, Enum.Operation.Call);
        return verifyCallResultFromTarget(target, success, returndata);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target
     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an
     * unsuccessful call.
     */
    function verifyCallResultFromTarget(address target, bool success, bytes memory returndata)
        internal
        view
        returns (bytes memory)
    {
        if (!success) {
            _revert(returndata);
        } else {
            // only check if target is a contract if the call was successful and the return data is empty
            // otherwise we already know that it was a contract
            if (returndata.length == 0 && target.code.length == 0) {
                revert AddressEmptyCode(target);
            }
            return returndata;
        }
    }

    /**
     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.
     */
    function _revert(bytes memory returndata) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert FailedInnerCall();
        }
    }
}
