{"abi":[{"type":"function","name":"getPrice","inputs":[{"name":"token0","type":"address","internalType":"address"},{"name":"token1","type":"address","internalType":"address"},{"name":"data","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"priceNumerator","type":"uint256","internalType":"uint256"},{"name":"priceDenominator","type":"uint256","internalType":"uint256"}],"stateMutability":"view"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"getPrice(address,address,bytes)":"355efdd9"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceNumerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceDenominator\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"CoW Protocol Developers\",\"details\":\"A contract that can be used by the CoW AMM as as a price oracle. The price source depends on the actual implementation; it could rely for example on Uniswap, Balancer, Chainlink...\",\"kind\":\"dev\",\"methods\":{\"getPrice(address,address,bytes)\":{\"details\":\"Calling this function returns the price of token1 in terms of token0 as a fraction (numerator, denominator). For example, in a pool where token0 is DAI, token1 is ETH, and ETH is worth 2000 DAI, valid output tuples would be (2000, 1), (20000, 10), ...To keep the risk of multiplication overflow to a minimum, we recommend to use return values that fit the size of a uint128.\",\"params\":{\"data\":\"Any additional data that may be required by the specific oracle implementation. For example, it could be a specific pool id for balancer, or the address of a specific price feed for Chainlink. We recommend this data be implemented as the abi-encoding of a dedicated data struct for ease of type-checking and decoding the input.\",\"token0\":\"The first token, whose price is determined based on the second token.\",\"token1\":\"The second token; the price of the first token is determined relative to this token.\"},\"returns\":{\"priceDenominator\":\"The denominator of the price, expressed in amount of token1 per amount of token0.\",\"priceNumerator\":\"The numerator of the price, expressed in amount of token1 per amount of token0.\"}}},\"title\":\"CoW AMM Price Oracle Interface\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/interfaces/IPriceOracle.sol\":\"IPriceOracle\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":100000},\"remappings\":[\":@openzeppelin/=lib/composable-cow/lib/@openzeppelin/\",\":composable-cow/=lib/composable-cow/\",\":cowprotocol/=lib/composable-cow/lib/cowprotocol/src/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":halmos-cheatcodes/=lib/openzeppelin/lib/halmos-cheatcodes/src/\",\":murky/=lib/composable-cow/lib/murky/src/\",\":openzeppelin-contracts/=lib/composable-cow/lib/murky/lib/openzeppelin-contracts/\",\":openzeppelin/=lib/openzeppelin/\",\":safe/=lib/composable-cow/lib/safe/\",\":uniswap-v2-core/=lib/uniswap-v2-core/contracts/\",\"lib/composable-cow:@openzeppelin/=lib/openzeppelin/contracts/\",\"lib/composable-cow:@openzeppelin/contracts/=lib/openzeppelin/contracts/\",\"lib/composable-cow:safe/=lib/composable-cow/lib/safe/contracts/\"]},\"sources\":{\"src/interfaces/IPriceOracle.sol\":{\"keccak256\":\"0xf954ab9dc44a0ce3612b65d803b59c3fe1f64803870328580c36802460c8c29e\",\"license\":\"GPL-3.0\",\"urls\":[\"bzz-raw://7cef4a090daa870e3c8cfa5d6498efae96427d4fe4e1a2784d26c088eea920e2\",\"dweb:/ipfs/QmU56CEHqif11NaomtVBNqrBTsV6CPPvjfN88SCe7V1Uxu\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.25+commit.b61c2a91"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"address","name":"token0","type":"address"},{"internalType":"address","name":"token1","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"stateMutability":"view","type":"function","name":"getPrice","outputs":[{"internalType":"uint256","name":"priceNumerator","type":"uint256"},{"internalType":"uint256","name":"priceDenominator","type":"uint256"}]}],"devdoc":{"kind":"dev","methods":{"getPrice(address,address,bytes)":{"details":"Calling this function returns the price of token1 in terms of token0 as a fraction (numerator, denominator). For example, in a pool where token0 is DAI, token1 is ETH, and ETH is worth 2000 DAI, valid output tuples would be (2000, 1), (20000, 10), ...To keep the risk of multiplication overflow to a minimum, we recommend to use return values that fit the size of a uint128.","params":{"data":"Any additional data that may be required by the specific oracle implementation. For example, it could be a specific pool id for balancer, or the address of a specific price feed for Chainlink. We recommend this data be implemented as the abi-encoding of a dedicated data struct for ease of type-checking and decoding the input.","token0":"The first token, whose price is determined based on the second token.","token1":"The second token; the price of the first token is determined relative to this token."},"returns":{"priceDenominator":"The denominator of the price, expressed in amount of token1 per amount of token0.","priceNumerator":"The numerator of the price, expressed in amount of token1 per amount of token0."}}},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"remappings":["@openzeppelin/=lib/composable-cow/lib/@openzeppelin/","composable-cow/=lib/composable-cow/","cowprotocol/=lib/composable-cow/lib/cowprotocol/src/","ds-test/=lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","halmos-cheatcodes/=lib/openzeppelin/lib/halmos-cheatcodes/src/","murky/=lib/composable-cow/lib/murky/src/","openzeppelin-contracts/=lib/composable-cow/lib/murky/lib/openzeppelin-contracts/","openzeppelin/=lib/openzeppelin/","safe/=lib/composable-cow/lib/safe/","uniswap-v2-core/=lib/uniswap-v2-core/contracts/","lib/composable-cow:@openzeppelin/=lib/openzeppelin/contracts/","lib/composable-cow:@openzeppelin/contracts/=lib/openzeppelin/contracts/","lib/composable-cow:safe/=lib/composable-cow/lib/safe/contracts/"],"optimizer":{"enabled":true,"runs":100000},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"src/interfaces/IPriceOracle.sol":"IPriceOracle"},"evmVersion":"cancun","libraries":{}},"sources":{"src/interfaces/IPriceOracle.sol":{"keccak256":"0xf954ab9dc44a0ce3612b65d803b59c3fe1f64803870328580c36802460c8c29e","urls":["bzz-raw://7cef4a090daa870e3c8cfa5d6498efae96427d4fe4e1a2784d26c088eea920e2","dweb:/ipfs/QmU56CEHqif11NaomtVBNqrBTsV6CPPvjfN88SCe7V1Uxu"],"license":"GPL-3.0"}},"version":1},"id":128}